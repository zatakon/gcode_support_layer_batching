#!/usr/bin/env python3
"""Main G-code processor with object-based layer batching.

This processor splits multi-object layers and batches by object for optimal tool changes.
"""

import argparse
import sys
from typing import List, TextIO
from pathlib import Path
from dataclasses import dataclass, field

from object_segment_parser import ObjectSegmentParser, ObjectLayer


@dataclass
class ObjectBatch:
    """Batch of object layers for a single tool."""
    tool: int
    start_layer: int
    end_layer: int
    object_layers: List[ObjectLayer] = field(default_factory=list)
    
    def layer_count(self) -> int:
        return len(self.object_layers)


class SimpleGCodeProcessor:
    """Simplified G-code processor with object-based batching."""
    
    def __init__(self, max_batch_layers: int = 10):
        self.object_parser = ObjectSegmentParser()
        self.max_batch_layers = max_batch_layers
        self.current_position = {'x': 0.0, 'y': 0.0, 'z': 0.0}
    
    def process_file(self, input_path: str, output_path: str) -> None:
        """Process G-code file with object-based batching."""
        print(f"Processing G-code file: {input_path}")
        
        # Parse and split into object segments
        print("Parsing G-code and splitting by object...")
        object_layers = self.object_parser.parse_file(input_path)
        print(f"Found {len(object_layers)} object segments")
        
        # Determine tools
        tools = sorted(set(ol.tool for ol in object_layers))
        print(f"Detected {len(tools)} tools: {tools}")
        
        # Create batches
        print("Creating object-based batches...")
        batches = self._create_batches(object_layers)
        
        # Print statistics
        tool_changes = len(batches) - 1
        print(f"\nBatching Statistics:")
        print(f"  Total object segments: {len(object_layers)}")
        print(f"  Total batches: {len(batches)}")
        print(f"  Tool changes: {tool_changes}")
        print(f"  Average batch size: {len(object_layers) / len(batches):.1f} segments")
        
        # Write output
        print(f"\nGenerating optimized G-code: {output_path}")
        with open(output_path, 'w', encoding='utf-8') as f:
            self._write_gcode(f, batches)
        
        print("Processing complete!")
    
    def _create_batches(self, object_layers: List[ObjectLayer]) -> List[ObjectBatch]:
        """Create batches by grouping object layers by tool."""
        # Group by tool
        by_tool = {}
        for ol in object_layers:
            if ol.tool not in by_tool:
                by_tool[ol.tool] = []
            by_tool[ol.tool].append(ol)
        
        # Sort each tool's layers
        for tool in by_tool:
            by_tool[tool].sort(key=lambda ol: ol.layer_number)
        
        # Create alternating batches
        batches = []
        tools = sorted(by_tool.keys())
        indices = {t: 0 for t in tools}
        
        tool_idx = 0
        total = len(object_layers)
        processed = 0
        
        while processed < total:
            # Find next tool with layers
            attempts = 0
            while attempts < len(tools):
                tool = tools[tool_idx % len(tools)]
                if indices[tool] < len(by_tool[tool]):
                    break
                tool_idx += 1
                attempts += 1
            
            if attempts >= len(tools):
                break
            
            # Create batch for this tool
            tool_layers = by_tool[tool]
            start = indices[tool]
            end = min(start + self.max_batch_layers, len(tool_layers))
            batch_layers = tool_layers[start:end]
            
            if batch_layers:
                batch = ObjectBatch(
                    tool=tool,
                    start_layer=batch_layers[0].layer_number,
                    end_layer=batch_layers[-1].layer_number,
                    object_layers=batch_layers
                )
                batches.append(batch)
                indices[tool] = end
                processed += len(batch_layers)
            
            tool_idx += 1
        
        return batches
    
    def _write_gcode(self, output: TextIO, batches: List[ObjectBatch]) -> None:
        """Write optimized G-code."""
        # Write header
        parser = self.object_parser.base_parser
        if parser.header_lines:
            for line in parser.header_lines:
                output.write(line)
                if not line.endswith('\n'):
                    output.write('\n')
        
        # Write info
        output.write("; ===== G-code optimized with OBJECT-BASED batching =====\n")
        output.write("; Generated by gcode_support_layer_batching\n")
        output.write(f"; Batches: {len(batches)}, Tool changes: {len(batches) - 1}\n")
        output.write(";\n\n")
        
        current_tool = None
        
        for batch_idx, batch in enumerate(batches):
            output.write(f"; Batch {batch_idx + 1}: Tool T{batch.tool}, "
                        f"Layers {batch.start_layer}-{batch.end_layer} "
                        f"({batch.layer_count()} segments)\n")
            
            # Tool change if needed
            if current_tool != batch.tool:
                if batch.object_layers and batch.object_layers[0].tool_change_commands:
                    output.write(f"; === Tool change to T{batch.tool} ===\n")
                    for cmd in batch.object_layers[0].tool_change_commands:
                        output.write(f"{cmd.raw_line}\n")
                else:
                    output.write(f"T{batch.tool} ; switch to tool {batch.tool}\n")
                current_tool = batch.tool
            
            # Write each object layer in batch
            for obj_layer in batch.object_layers:
                output.write(f"; Object segment: Layer {obj_layer.layer_number} at Z={obj_layer.z_height:.3f}\n")
                
                for cmd in obj_layer.commands:
                    # Update position tracking
                    if cmd.x is not None:
                        self.current_position['x'] = cmd.x
                    if cmd.y is not None:
                        self.current_position['y'] = cmd.y
                    if cmd.z is not None:
                        self.current_position['z'] = cmd.z
                    
                    output.write(f"{cmd.raw_line}\n")
            
            output.write("\n")
        
        # Write footer
        output.write("; End of optimized G-code\n")
        output.write("M104 S0 ; turn off extruder\n")
        output.write("M140 S0 ; turn off bed\n")
        output.write("G28 X Y ; home X and Y\n")
        output.write("M84 ; disable motors\n")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Post-process multi-object G-code with object-based batching'
    )
    
    parser.add_argument('input', help='Input G-code file')
    parser.add_argument('output', help='Output G-code file')
    parser.add_argument('--max-batch-layers', type=int, default=10,
                       help='Maximum layers per batch (default: 10)')
    
    args = parser.parse_args()
    
    if not Path(args.input).exists():
        print(f"Error: Input file not found: {args.input}", file=sys.stderr)
        return 1
    
    processor = SimpleGCodeProcessor(max_batch_layers=args.max_batch_layers)
    
    try:
        processor.process_file(args.input, args.output)
        return 0
    except Exception as e:
        print(f"Error processing G-code: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())
